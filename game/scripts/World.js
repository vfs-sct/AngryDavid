/*
 * World Controller Class
 *
 *   Manage RigidBodies in a box2D world
 *
 * Copyright 2014-2017, Kibble Games.  All Rights Reserved.
 */
'use strict';

import HTTP from '/common/libs/http.js';

import Physics from '/common/libs/Physics.js';
import Point from './Point.js';

/*
 * The World
 */
export default class World {

	constructor( $element ) {
        // self members
        let height = $element.height() / Physics.WORLD_SCALE;
        let width = $element.width() / Physics.WORLD_SCALE;

        let my = this.__private__ = {
            $view:       $element,
            viewSize:    {
                x: $element.width() / Physics.WORLD_SCALE,
                y: $element.height() / Physics.WORLD_SCALE,
            },
            model:       null,
            size:        null,
            level:       null,
            debugRender: false,
            debugDraw: null
        };

        my.model = new Physics.World( new Physics.Vec2( 0, Physics.GRAVITY ) ,true );

        this.#_createBoundaries();
        this.#_addListeners();
	}


	update() {
        let my = this.__private__;

        my.model.Step( 1/60, 10, 10 ); // frame-rate, velocity iterations, position iterations
        my.model.ClearForces();
    }


    render() {
        // not much to do here unless we add the entity list here.
    	let my = this.__private__;
        if (!my.debugRender)
            return;

        my.debugDraw = new Physics.DebugDraw();

        let ctx = $('#debug-canvas').get(0).getContext("2d");
        my.debugDraw.SetSprite( ctx );
        my.debugDraw.SetDrawScale( Physics.WORLD_SCALE );
        my.debugDraw.SetFillAlpha( 0.3 );
        my.debugDraw.SetLineThickness( 1.0 );
        my.debugDraw.SetFlags( Physics.DebugDraw.e_shapeBit | Physics.DebugDraw.e_jointBit );
        my.model.SetDebugDraw( my.debugDraw );
    }


    loadLevel( name = "") {
    	let my = this.__private__;
        return new Promise( async ( resolve, reject ) => {

            let resultString = await HTTP.post('/api/load/shenshaw', { name, type:'level'});
            let result = JSON.parse( resultString );
            if (result.error)
                throw( { code: result.error, msg: result.errMsg });

            let level = JSON.parse( result.payload );
            resolve( level );
        })
        .catch( error => {
            if (error.msg) console.log( error.msg );
            let code = (error.code ? error.code : error);
            reject( error.code )
        })
    }


    get model()              { return this.__private__.model; }
    get worldModel()         { return this.__private__.model; }
    get debugRenderEnabled() { return this.__private__.debugRender; }

    disableDebugRender() { this.__private__.debugRender = false; }
    enableDebugRender()  { this.__private__.debugRender = true; }


    #_addListeners() {

    	let my = this.__private__;
        /*
         * Don't create or destroy any physics entities in these event handlers, store the info to
         * manage in an update later.
         *
         * The Contact object is generated by Box2D to contain the collision info
         * It also contains a method to get the two fixtures that collided
         * Use them to inspect the user data.
         *
         * its key that the user data have info identifying the dom element so you can manipulate.
         *
         */
        let listener = new Physics.Listener;

        listener.BeginContact = ( contact ) => {
            //
            // console.log(contact.GetFixtureA().GetBody().GetUserData());
            //
            // This is called when two fixtures begin to overlap.
            //
            let thingA = contact.GetFixtureA().GetBody().GetUserData();
            let thingB = contact.GetFixtureB().GetBody().GetUserData();

            if ((thingA == null) || (thingB == null))
                return;

            let idA = thingA.$element.attr('id');
            let idB = thingB.$element.attr('id');

            if ((idA == 'crate-one' && idB != 'bird1') || (idA != 'bird1' && idB == 'crate-one')) {
                console.log("Crate One was hit by another crate");
            }
        }

        listener.EndContact = ( contact ) => {
            //
            // console.log(contact.GetFixtureA().GetBody().GetUserData());
            //
            // This is called when two fixtures cease to overlap.
            //
        }

        listener.PreSolve = ( contact, oldManifold ) => {
            //
            // PreSolve
            //
            // This is called after collision detection, but before collision resolution.
            // This gives you a chance to disable the contact based on the current configuration.
            //
        }

        listener.PostSolve = ( contact, impulse ) => {
            //
            // PostSolve
            //
            // The post solve event is where you can gather collision impulse results. If you donï¿½t care about the impulses,
            // you should probably just implement the pre-solve event.
            //
            //if (contact.GetFixtureA().GetBody().GetUserData() == 'ball' || contact.GetFixtureB().GetBody().GetUserData() == 'ball') {
            //
            //    console.log(world.ball.impulse);
            //}
            let thingA = contact.GetFixtureA().GetBody().GetUserData();
            let thingB = contact.GetFixtureB().GetBody().GetUserData();

            if ((thingA == null) || (thingB == null))
                return;

            if (thingA.$element.attr('id') == 'bird1') {
                // possible win, we have a bird
                // possible wall, if its the ceiling win?
            }
        }

        my.model.SetContactListener( listener );
    }


    #_createBoundaries() {
    	let my = this.__private__;

        // Create the ground fixture definition
        let body_defn = new Physics.BodyDef;
        body_defn.type = Physics.Body.b2_staticBody;

        let fixture_defn = new Physics.FixtureDef;
        fixture_defn.density = 10.0;
        fixture_defn.friction = 1.0;
        fixture_defn.restitution = 0.1;
        fixture_defn.shape = new Physics.PolygonShape;

        //add four walls to the static body
        //fixture_defn.shape.SetAsBox( width, height, Physics.Vec2( center-x, center-y ), angle)
        let max = my.viewSize;
        let mid = new Point( max.x / 2, max.y /2 );
        let h = 1.0;

        let width = 0.5;               // Wall Width world units
        let half_width = width / 2.0;  // half wall width.

        this.#_createBoundary('ground',     body_defn, fixture_defn, { x:mid.x, y:max.y, w:max.x, h:width });
        this.#_createBoundary('right-wall', body_defn, fixture_defn, { x:max.x - half_width, y:mid.y, w:width, h:max.y });
        this.#_createBoundary('left-wall',  body_defn, fixture_defn, { x:0 + half_width, y:mid.y, w:width, h:max.y });
        this.#_createBoundary('top-wall',   body_defn, fixture_defn, { x: mid.x, y:0 + half_width, w:max.x, h:width });
    }


    #_createBoundary( name, aBody, aFixture, boundingBox, debugColor = 'green' ) {

    	let my = this.__private__;

    	let centre = new Point( boundingBox.x, boundingBox.y );
    	let ext = new Point( boundingBox.w, boundingBox.h );

        aBody.position.Set( centre.x, centre.y );
        aFixture.shape.SetAsBox( ext.x, ext.y, centre.asVec2(), 0 );

        my.model.CreateBody( aBody ).CreateFixture( aFixture );

        this.#_renderDebugModel( name, ext.x, ext.y, centre.x, centre.y, debugColor );
    }


    #_renderDebugModel( name, w, h, x, y, color ) {

    	let my = this.__private__;

        let debugColor = (my.debugRender ? color : 'transparent');
        let elementId = name + "-debug";

        let screen = {
            width:  Math.floor( w * Physics.WORLD_SCALE ),
            height: Math.floor( h * Physics.WORLD_SCALE ),
            left:   Math.floor( (x * Physics.WORLD_SCALE) - (w / 2 * Physics.WORLD_SCALE) ),
            top:    Math.floor( (y * Physics.WORLD_SCALE) - (h / 2 * Physics.WORLD_SCALE) )
        };

        // create a div with class debug, and append it in position
        $('#wrapper').append(`<div id="${elementId}" class="debug"></div>`);
        $(`#${elementId}`).css({
            'width' : screen.width + "px", // screen.width + "px",
            'height': screen.height + "px",   // screen.height + "px",
            'left'  : screen.left + "px",
            'top'   : screen.top + "px",
            'border-color': debugColor
        });
    }
}
